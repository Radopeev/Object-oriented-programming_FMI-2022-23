Small String Optimazation за клас MyString(имплементацията на Ангел Димитриев) - Документация
1) Добавил съм променлива capacity, която ще помага да се следи колко памет е задалена за динамичния масив(в случай , че е заделена такава)
2) Направил съм union, в който съм сложил една структура , коята съдържа указателя за динамичната памет и капацитета, извън нея в union-a има статичен char масив.
Така паметта на обекта ще се поделя между тях и спряма дължината му можем да пазим данните в самия обект, ако е достатъчно малък
3) Имам статична променлива, която ще е равна на размера на обединението(sizeof(buff))
4) Имаме две нови private функции, койте се ползват при конкатенация на обекти с оператор +=
  –>memoryAllocation се ползва, когато искаме да добавим стринг към сегашния, чиито данни са в статичния масив. Тогава се извиква тази функция и се заделя достатъчно памет
   и се копира досегашния масив в динамичния, за да се поберат досегашния масив и този,с който искаме да го конкатенираме.
  ->resizeForConcatenations се ползва, когато искаме да добавим стринг към сегашния, чиито данни са в динамичния масив. Тогава се извиква тази функция, за да се задели достатъчно 
  памет и за двата стринга.
5) Функцията isSSO се ползва, за да се пазят данните на обекта. Ако дължината му е по-голяма от статичната променлива значи се пази в динамичната памет, иначе се пази в статичната.
6) Голямата четворка почти не е променяна просто се включва isSSO функцията, за да се знае откъде трябва да се копират данните при copyFrom , дали трябва се освободят при 
   fre и дали да се пазят в динамичната памет или в статичната при конструктура.
7) Оператор += има 5 случая според това къде се пазят данните и на двата обекта и къде трябва да се запази резултата
   -> Ако имаме два малки стринга и тяхната конкатенация е малък стринг просто ги конкатенираме.
   -> Ако имаме два малки стринга и тяхната конкатенация е голям стринг се заделя памет се копират данните на единия и другия в динамичната част на union-a.
   -> Ако първия е голям , а втория не е, се прави resize на динамичния масив , след което се конкатенират
   -> Ако първия малък, а втория не е , се заделя памет и после се конкатенират
   -> Ако и двата са големи пак се прави resize и се конкатанират
Тези проверки са за да сме сигурни къде се пазят данните на двата обекта и къде ще се пазят след конкатенаията
8) Функията substr работи както преди просто сега е нужна проверка къде се пазят данните 
9) Аналогочни работят operator[] и c_str
10) Оператор+ работо почти като оператор+=. Създаваме обект, който спрямо дължината на подадените ще се задели памет ако са твърде големи
и имаме проверки, за да знаем къде са данните и на двата обекта(в коя памет са).  